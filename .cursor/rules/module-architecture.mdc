---
description: Правила создания и проверки модулей проекта — архитектура, SOLID, ошибки, инкапсуляция, документация. Применяется при работе с модулями в com.example.interhubdev.
alwaysApply: true
---

# Архитектура модулей InterhubDev

Это правило описывает, как создавать новые модули, проверять существующие и поддерживать единообразие архитектуры. Следуй ему при любых изменениях внутри модуля и его зависимостей.

---

## 1. Обзор архитектуры проекта

### 1.1 Модульная структура (Spring Modulith)

- Модули живут в `com.example.interhubdev.<module>`.
- Каждый модуль объявляется через `@ApplicationModule` в `package-info.java` с `displayName` и `allowedDependencies`.
- **Публичный контракт модуля** — только то, что не в пакете `internal`. Внешние модули могут зависеть только от публичных типов (API-интерфейсы, DTO, запросы/ответы, enum, порты).
- Всё, что является деталью реализации (контроллеры, сервисы, репозитории, сущности, мапперы, валидация), должно находиться в пакете **`internal`** и не экспортироваться.

### 1.2 Стандартная структура одного модуля

```
com.example.interhubdev.<module>/
├── package-info.java          # @ApplicationModule, описание модуля, allowedDependencies
├── <Module>Api.java            # Публичный интерфейс API (фасад модуля)
├── *Dto.java, *Request.java    # Публичные DTO и запросы (если нужны другим модулям)
├── *Page.java, *Item.java      # Публичные типы ответов (страницы, элементы списков)
├── <Type>.java                 # Публичные enum, порты (интерфейсы для обратных зависимостей)
└── internal/
    ├── <Module>Controller.java # REST-контроллер (один на модуль или логическая группа)
    ├── <Module>ServiceImpl.java # Реализация <Module>Api (или несколько *Service)
    ├── <Module>Errors.java     # Модульные ошибки (опционально; иначе только Errors)
    ├── *Service.java           # Внутренние сервисы (каталог, доменная логика)
    ├── *Validation.java        # Внутренние валидаторы (бизнес-правила)
    ├── *Mappers.java           # Entity → DTO маппинг (внутренний)
    ├── *Repository.java        # JPA-репозитории (если модуль хранит данные)
    ├── *.java                  # JPA-сущности, внутренние типы
    └── (request records)       # Request-типы можно держать в контроллере или отдельно
```

- **Правило зависимостей**: модуль может зависеть только от модулей, перечисленных в `allowedDependencies`. Обязательно включать **`error`** для любого модуля, который бросает исключения в сторону API.
- **Правило видимости**: классы в `internal` — package-private (`class`, без `public`), если не требуются Spring-бинами из того же пакета.

---

## 2. Модуль error — единая точка обработки ошибок

### 2.1 Обязательное использование

- Все ошибки, которые должны вернуться клиенту как HTTP-ответ с телом в формате **ErrorResponse** (`code`, `message`, `timestamp`, `details`), должны идти **только через модуль `error`**.
- Не бросать сырые `RuntimeException`, `IllegalArgumentException` без учёта того, что их обрабатывает `GlobalExceptionHandler` (для простых случаев это допустимо, но предпочтительно явно использовать `Errors` или модульные `*Errors`).
- Не создавать собственные типы ответов об ошибках в других модулях: единый формат — `com.example.interhubdev.error.ErrorResponse`.

### 2.2 Как бросать ошибки

- **Общие кейсы**: использовать фабрики из `com.example.interhubdev.error.Errors`:
  - `Errors.badRequest("message")`, `Errors.notFound("message")`, `Errors.conflict("message")`, `Errors.unauthorized("message")`, `Errors.forbidden("message")`, `Errors.unprocessable("message")`.
  - С деталями: `Errors.badRequest("message", detailsObject)`.
  - Произвольный статус/код: `Errors.of(HttpStatus, "CODE", "message")` или с `details`.
- **Модульные коды и сообщения**: для стабильного контракта с фронтом завести в модуле класс `internal/<Module>Errors` (утилитарный класс, приватный конструктор, статические методы, возвращающие `AppException`). Пример:

```java
// internal/AccountErrors.java
public final class AccountErrors {
    private AccountErrors() {}
    public static final String CODE_USER_NOT_FOUND = "ACCOUNT_USER_NOT_FOUND";
    public static AppException userNotFound(UUID id) {
        return Errors.of(HttpStatus.NOT_FOUND, CODE_USER_NOT_FOUND, "Пользователь не найден: " + id);
    }
}
```

- В контроллерах и сервисах: `throw AccountErrors.userNotFound(id);` вместо прямого `throw Errors.notFound(...)` при необходимости единого кода ошибки по модулю.
- Сообщения в исключениях должны быть пригодны для отображения пользователю (или явно логировать технические детали отдельно, не подставлять в `message` чувствительные данные).

### 2.3 Запреты

- Не дублировать логику преобразования исключений в HTTP-ответ в модулях; всё обрабатывает `GlobalExceptionHandler` в модуле `error`.
- Не экспортировать из других модулей свои исключения как часть публичного API (клиент API видит только `ErrorResponse`).

---

## 3. Публичный API модуля (фасад)

### 3.1 Интерфейс *Api

- Каждый модуль, предоставляющий поведение другим модулям или REST, имеет публичный интерфейс `<Module>Api` в корне пакета модуля.
- Контроллер зависит только от `<Module>Api` и вызывает его методы. Реализация (`*ServiceImpl`) в `internal` реализует этот интерфейс.
- Методы API должны быть **понятно названы** и принимать/возвращать **только публичные типы** (DTO, базовые типы, UUID, Optional, коллекции публичных DTO). Не передавать сущности JPA, репозитории или внутренние типы через API.

### 3.2 Документирование API

- На интерфейс `<Module>Api` — Javadoc с кратким назначением модуля.
- На каждый метод — Javadoc: назначение, параметры (`@param`), возвращаемое значение (`@return`), возможные исключения (что бросается при нарушении контракта, например not found / conflict). Упоминать, что ошибки идут через модуль `error` (AppException/Errors).

Пример:

```java
/**
 * Get user by ID (plain user, no profiles).
 *
 * @param id user ID
 * @return optional user DTO if found
 * @throws AppException via Errors / ModuleErrors e.g. not found (handled by global handler)
 */
Optional<UserDto> getUser(UUID id);
```

---

## 4. Слои внутри модуля и разделение ответственности

### 4.1 Controller (internal)

- Один (или несколько по логическим группам) REST-контроллер в `internal`.
- Делает только: парсинг запроса (path, query, body), вызов метода(ов) `<Module>Api`, возврат ResponseEntity с DTO.
- Не содержит бизнес-логики. Валидация запроса — через Bean Validation (`@Valid`) и при необходимости проверки в API-реализации.
- При отсутствии сущности вызывать API и при `Optional.empty()` бросать исключение через `Errors` или `<Module>Errors` (контроллер не должен сам решать код ошибки, кроме как через фабрики ошибок).
- Контроллер должен быть тонким: минимум ветвлений, делегирование всей логики в API.

### 4.2 Service (реализация API и внутренние сервисы)

- Класс `*ServiceImpl` в `internal` реализует `<Module>Api` и инжектит только зависимости из разрешённых модулей (по `allowedDependencies`) плюс внутренние сервисы/репозитории.
- Крупные домены можно разбить на внутренние сервисы (например `ProgramCatalogService`, `CurriculumService`), а `ProgramServiceImpl` их оркестрирует и реализует `ProgramApi`.
- Транзакции: на read-методах — `@Transactional(readOnly = true)`, на write — `@Transactional`. Не открывать транзакции без необходимости и не вызывать из одного модуля множество внешних API в цикле без пагинации (риск N+1 и таймаутов).

### 4.3 Валидация

- Запросы к API: обязательные поля и формат — через Bean Validation на DTO/record запроса.
- Бизнес-правила (уникальность кода, существование связанных сущностей, диапазоны) — в сервисах. Повторяющуюся проверку можно вынести в `internal/*Validation` (статические методы или утилитарный класс), которые при нарушении бросают `Errors.badRequest(...)` / `Errors.conflict(...)` и т.д.
- Не дублировать одни и те же проверки в контроллере и сервисе: контроллер доверяет API; сервис — единственное место бизнес-валидации.

### 4.4 Маппинг Entity → DTO

- Маппинг только в `internal` (например `*Mappers`). Публичные DTO не должны знать о сущностях JPA.
- Маппер — статические методы или отдельный класс без состояния. Entity не должны утекать за пределы слоя репозитория/сервиса в виде возвращаемых значений API или параметров.

### 4.5 Репозитории и сущности

- JPA-сущности и репозитории — только в `internal`. Не экспортировать сущности в публичный API модуля.
- Запросы к БД должны быть эффективными: избегать N+1 (при необходимости fetch join, entity graph или отдельные запросы по списку id с одним batch), не загружать большие коллекции без пагинации.
- Инкапсуляция: сущности могут иметь сеттеры для JPA/ORM, но бизнес-логику предпочтительно держать в сервисах; не передавать сущности в другие модули.

---

## 5. SOLID и практики проектирования

### 5.1 Single Responsibility (SRP)

- Один класс — одна зона ответственности: контроллер — HTTP; API-интерфейс — контракт; сервис — оркестрация и бизнес-правила; валидатор — проверки; маппер — преобразование; репозиторий — персистентность.
- Не смешивать в одном классе, например, маппинг, валидацию и отправку писем. Выносить в отдельные классы/методы.

### 5.2 Open/Closed (OCP)

- Расширять поведение через новые реализации (например новые сервисы или стратегии), а не менять существующие классы без необходимости. Публичный API модуля менять с осторожностью (обратная совместимость).
- Использовать интерфейсы для зависимостей (например порты для обратных зависимостей между модулями), чтобы подставлять разные реализации.

### 5.3 Liskov Substitution (LSP)

- Реализации API и любые подтипы должны быть подставляемы без нарушения контракта: те же предусловия/постусловия, не бросать необъявленные проверяемые исключения, не сужать возвращаемые типы несовместимым образом.

### 5.4 Interface Segregation (ISP)

- Интерфейсы модуля (Api, порты) не должны заставлять клиентов зависеть от методов, которые они не используют. Предпочтительно узкие порты (например `OfferingLookupPort.existsById`) вместо тяжёлых фасадов, если модуль нужен только для одной проверки.

### 5.5 Dependency Inversion (DIP)

- Модуль не должен зависеть от конкретной реализации другого модуля, а от абстракции (другой модуль's Api или порт). Обратные зависимости (например Schedule нуждается в проверке Offering) решаются через **порты**: в Schedule объявляется интерфейс `OfferingLookupPort`, реализация живёт в `adapter` и внедряет Offering-логику. В `allowedDependencies` Schedule не указывает offering; связь идёт через адаптер.

---

## 6. Порты и адаптеры (межмодульные зависимости)

- Если модуль A должен использовать факт из модуля B, но прямая зависимость A → B создаёт цикл или нежелательную связность:
  - В модуле A объявить **порт** (интерфейс) в публичной части A, например `OfferingLookupPort` в schedule.
  - Реализацию порта (адаптер) разместить в пакете **adapter**, зависящем от B (или от порта B). Модуль A в `allowedDependencies` не указывает B.
- Так сохраняется направление зависимостей и избегаются циклы. Все ошибки при использовании порта по-прежнему через модуль `error` (например при несуществующем id бросать `Errors.notFound(...)` в сервисе A).

---

## 7. Документирование кода (для AI и поддержки)

### 7.1 Классы

- Публичные классы/интерфейсы модуля: краткий Javadoc (что это и зачем).
- Классы в `internal`: хотя бы однострочный Javadoc (назначение класса). Для утилитарных классов без состояния — указать, что экземпляр не создаётся (private constructor).

### 7.2 Методы

- Публичный API (интерфейс *Api): полный Javadoc — описание, `@param` для каждого параметра, `@return`, при необходимости `@throws` (AppException или типы из error).
- Публичные методы DTO/запросов (если есть неочевидные контракты) — кратко.
- Внутренние методы: для неочевидной логики — краткий комментарий или Javadoc (зачем проверка, какое бизнес-правило).
- Геттеры/рекорды: при неочевидной семантике (nullable, единицы измерения, формат) — описать в Javadoc типа/DTO.

### 7.3 Константы и коды ошибок

- Константы кодов ошибок в `*Errors`: кратко описать, когда используются.
- Магические числа вынести в именованные константы с комментарием (например MAX_PAGE_SIZE, MIN_YEAR).

---

## 8. Безопасность данных и эффективность

### 8.1 Утечка данных

- Не возвращать в API и не логировать чувствительные данные (пароли, токены, полные персональные данные без необходимости). В сообщениях об ошибках не подставлять внутренние id, стек-трейсы или детали БД; при необходимости логировать их отдельно с уровнем debug.
- DTO должны содержать только те поля, которые разрешены для данного эндпоинта и роли. Не отдавать лишние поля из сущностей «на будущее».

### 8.2 Эффективность

- Избегать N+1: при загрузке коллекций и связей использовать batch-запросы, fetch join или отдельный сервисный метод с явным списком id.
- Пагинация: списки, которые могут быть большими, должны быть постраничными (cursor или offset) с ограничением размера страницы. Не загружать все записи в память для сортировки на стороне приложения, если это можно сделать в БД.
- Транзакции: не держать длинные транзакции при внешних вызовах (HTTP, почта); при необходимости выполнять внешние вызовы после коммита или в отдельной транзакции.
- Кэширование: при повторяющихся тяжёлых запросах рассмотреть кэш (Spring Cache и т.п.), не кэшировать чувствительные данные без учёта TTL и инвалидации.

### 8.3 Инкапсуляция

- Внутреннее состояние сущностей не должно быть доступно произвольно: не отдавать сущности наружу модуля; не давать другим модулям менять внутренние коллекции DTO (возвращать копии или неизменяемые коллекции при необходимости).
- Публичные DTO — по возможности неизменяемые (record, final поля, копии коллекций в геттерах). Внутренние типы в `internal` при необходимости мутабельны, но не утекают наружу.

---

## 9. Чек-лист: создание нового модуля

1. Создать пакет `com.example.interhubdev.<module>` и `internal`.
2. В `package-info.java`: `@ApplicationModule(displayName = "...", allowedDependencies = {"...", "error"})`, Javadoc с описанием модуля, публичного API и зависимостей.
3. Определить публичный интерфейс `<Module>Api` с полным Javadoc методов.
4. Ввести нужные DTO/запросы/ответы в корне пакета; всё, что только для контроллера (request DTO), можно в `internal` или в конце контроллера как record.
5. Реализация: `internal/<Module>ServiceImpl` реализует `<Module>Api`; при необходимости разбить на внутренние сервисы.
6. Ошибки: либо только `Errors.*`, либо дополнительно `internal/<Module>Errors` с константами кодов и фабриками `AppException`. Все исключения — через `com.example.interhubdev.error`.
7. REST: `internal/<Module>Controller`, инжект только `<Module>Api`; тонкий слой, вызов API и маппинг в ResponseEntity.
8. Валидация: Bean Validation на запросах; бизнес-правила в сервисах или `*Validation`.
9. Маппинг Entity → DTO только в `internal` (например `*Mappers`).
10. Репозитории и сущности — только в `internal`; не экспортировать.
11. При обратной зависимости к другому модулю — порт в своём модуле + адаптер в пакете `adapter`.
12. Проверить: нет зависимостей вне `allowedDependencies`; нет утечки сущностей и внутренних типов; нет дублирования обработки ошибок; методы и классы задокументированы.

---

## 10. Чек-лист: проверка существующего модуля

- **Зависимости**: в `package-info` указаны все используемые модули, включая `error` при использовании Errors/AppException.
- **Публичный API**: только Api, DTO, запросы/ответы, enum, порты; никаких Controller/Service/Entity/Repository в корне пакета.
- **Ошибки**: все пользовательские ответы об ошибках через `Errors` или модульный `*Errors`; нет собственного формата ответа об ошибке.
- **Контроллер**: тонкий, только вызов Api и преобразование в ResponseEntity; валидация запроса через @Valid и сервис.
- **Сервисы**: бизнес-логика и валидация в сервисах; транзакции проставлены корректно; нет N+1 и избыточной загрузки данных.
- **Документация**: Javadoc на публичном API и на внутренних классах/методах там, где логика неочевидна.
- **Данные**: нет утечки чувствительных данных в ответах и логах; DTO не содержат лишних полей; коллекции при необходимости неизменяемые/копии.
- **Инкапсуляция**: сущности и внутренние типы не отдаются за пределы модуля; маппинг только во внутреннем слое.

---

## 11. Краткая сводка для агента

- Модуль = публичный пакет + `internal`; публично только Api, DTO, порты, enum.
- Все ошибки к клиенту — через модуль **error** (Errors или *Errors), единый формат ErrorResponse.
- Контроллер тонкий; сервис реализует Api и содержит бизнес-логику; валидация — @Valid + внутренняя в сервисах/*Validation.
- Entity и репозитории только в internal; маппинг Entity→DTO во внутренних Mappers.
- Зависимости строго по allowedDependencies; обратные зависимости — через порты и адаптеры.
- SOLID: один класс — одна ответственность; зависимость от абстракций; узкие порты.
- Подробные комментарии/Javadoc на Api и неочевидной логике; без утечки данных и неэффективных запросов; хорошая инкапсуляция (внутреннее не утекает, DTO неизменяемые где возможно).

При любом изменении в модуле или его зависимостях сверяйся с этим правилом и чек-листами выше.
